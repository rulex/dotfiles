#!/bin/bash
alias ..='cd ..'
alias ...='cd ../..'
alias -- -='cd -'

alias please='sudo'
alias rm='rm -I'

alias ls='ls -F --color=auto --time-style="+%Y-%m-%d %H:%M:%S" '
alias lsa='ls -lah'
alias l='ls -lah'
alias ll='ls -l'
alias la='ls -lA'
alias lc='ls -lthrc'
alias lca='ls -ltrca'
alias sl=ls
alias lt='tree'

#alias dt='date +"%Y-%m-%dT%H:%M:%S"'
function dt() {
    if [[ $# == 0 ]]; then
        # pretty print now
        date +"%Y-%m-%d %H:%M:%S"
    elif [[ $# == 1 ]]; then
        if [[ $1 == "w" ]]; then
            date +"%Y-%m-%d %H:%M:%S W%V"
        else
            # pretty print input unix ts
            # TODO check if $1 is number aka it is unix timestamp OR...
            date +"%Y-%m-%d %H:%M:%S" --date @"$1"
        fi
    elif [[ $# == 2 ]] && [[ $1 == "p" ]]; then
        pretty_time ${2}
    elif [[ $# == 2 ]]; then
        # diff between two dates
        d1=$(date -d "$1" +%s)
        d2=$(date -d "$2" +%s)
        pretty_time (($d2 - $d1))
    fi
}

#function say() {
#    local IFS=+
#    mpv --volume 60 "http://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&q=$*&tl=en"
#}

# keyboard LEDs as notification default values
export LED_ID=3 # scroll lock
export LED_REPEAT=1
export LED_ON=0.5
export LED_OFF=0.5

led_on() {
    xset led ${1:-${LED_ID}} > /dev/null 2>&1
}

led_off() {
    xset -led ${1:-${LED_ID}} > /dev/null 2>&1
}

led_toggle() {
    LED_ID=${1:-${LED_ID}}
    if led_is_on; then
        led_off
    else
        led_on
    fi
}

function led_is_on() {
    if [ ${LED_ID} -eq 1 ]; then
        # FIXME
        echo "LED is on check for ${LED_ID} is not supported"
    elif [ ${LED_ID} -eq 2 ]; then
        # FIXME
        echo "LED is on check for ${LED_ID} is not supported"
    elif [ ${LED_ID} -eq 3 ]; then
        xset q | grep Scroll | cut -c70-72 | grep -q on
    else
        echo "LED is on check for ${LED_ID} is not supported"
    fi
}

function led_blink() {
    local LED_REPEAT=${1:-${LED_REPEAT}}
    local LED_ID=${2:-${LED_ID}}
    local LED_ON=${3:-${LED_ON}}
    local LED_OFF=${4:-${LED_OFF}}
    for i in $(seq 1 ${LED_REPEAT}); do
        if [ ${i} -eq 1 ]; then
            LED_WAIT=0
        else
            LED_WAIT=$( echo "(${LED_ON}+${LED_OFF})*(${i}-1)" | bc )
        fi
        ( ( sleep ${LED_WAIT} ; led_on ; sleep ${LED_ON} ; led_off ; sleep ${LED_OFF} ) &)
    done
}

function ds() {
    if [[ $# == 0 ]]; then
        du --time --time-style="+%Y-%m-%d %H:%M:%S" -shc * | sort -k 1 -h
    else
        du --time --time-style="+%Y-%m-%d %H:%M:%S" -shc $* | sort -k 1 -h
    fi
}

function json_escape() {
    printf '%s' "${1}" | python -c 'import json,sys; print(json.dumps(sys.stdin.read()))'
}

function e() {
    nvim ${*} || vim ${*} || vi ${*}
}

function :e() {
    e ${*}
}

function es() {
    if [ -f vimsession ]; then
        e -S vimsession
    elif [ -f package.json ]; then
        e package.json
    else
        e
    fi
}

alias new_uuid='cat /dev/urandom | tr -dc "a-zA-Z0-9" | fold -w 32 | head -n 1'
random-string() {
    cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w ${1:-32} | head -n 1
}

function px() {
    if [[ $# == 0 ]]; then
        ps auxf
    elif [[ $# -ge 1 ]]; then
        ps auxf | grep -i $*
    fi
}

function pwatch() {
    local re='^[0-9]+$'
    echo "${1}"
    if ! [[ ${1} =~ $re ]] ; then
        watch -g pgrep ${1}
    else
        watch -g ps -opid -p ${1}
    fi
    #A "${1} is done"
}

function agrep() {
    # align grep
    grep -Hni "${1}" ${@} | sed -e "s#:#¤#" -e "s#:#¤#" | column -t -s "¤" -o " | " -N file,line,content | grep -i "${1}"
}

alias f='find'
compdef fn=find
function fn() {
    if [[ $# -eq 0 ]]; then
        return 1
    elif [[ $# -eq 1 ]]; then
        find . -iname "*${1}*"
    elif [[ $# -ge 1 ]]; then
        find ${2} -iname "*${1}*" ${@:3}
    fi
}

alias grep='grep --color=auto'
alias egrep='egrep --color=auto'
alias -g align='sed -e "s#¤#|#" -e "s#:#¤#" | column -t -s "¤" -o " | "'

alias xterm='xterm -bg black -fg white'

alias p='pacman'
alias P='packer'
alias s='sudo '
alias w='w -f'
alias fig='docker-compose'
alias t='tmux'
alias tmuxeey='new -d -s "default" \
    new-window   \; \
    new-window   \; \
    new-window   \; \
    new-window   "htop" \; \
    split-window -h "nmon" \; \
    split-window -v "watch sensors" \; \
    select-pane -L \; \
    split-window -v "journalctl -alf" \; \
    attach \;'
alias tmuxmon='tmux \
    new-window   "htop" \; \
    split-window -h -p 35 "NMON=ld nmon" \; \
    split-window -v "watch -d sensors" \; \
    select-pane -L \; \
    split-window -v "journalctl -alf" \;'

alias netlisteners='lsof -i -P | grep LISTEN'
alias g='git'
alias gs='git status'
alias ga='git add'
alias gb='git branch'
alias gba='git branch -av'
alias gc='git commit'
alias gcv='git commit --verbose'
alias gd='git diff'
alias gco='git checkout'
alias gm='git merge'
alias gl="git log --color --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen[%ci (%cr)] %C(bold blue)<%an>%Creset' --abbrev-commit"
alias glh="git log --color --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit|head"
alias gls="git log --color --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %C(bold blue)<%an>%Creset' --abbrev-commit"
alias glg="git log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen[%ci (%cr)] %C(bold blue)<%an>%Creset' --abbrev-commit"
alias glga="git log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen[%ci (%cr)] %C(bold blue)<%an>%Creset' --abbrev-commit --all"
alias gln='git log --color --pretty=format:"%C(red)%h%C(reset) - %s %C(green)[%ci (%cr)] %C(bold blue)<%an>%C(reset)" --name-only'
#alias gls='git show --color --pretty=format:"%C(red)%h%C(reset) - %s %C(green)[%ci (%cr)] %C(bold blue)<%an>%C(reset)"'
alias glc='git shortlog --color --no-merges -nes'
alias grup='git remote update'
alias gwc='git whatchanged -p --abbrev-commit --pretty=medium'

alias mysql='mysql --auto-rehash'
alias cv='progress'

function logstr() {
    # replace newline with newline+tab for extra fancy indented text
    logstr=$( echo "${1//
/
    }" )
    echo "$(dt) ${logstr}" >> ~/.a.log
}

function A() {
    # led notification
    led_blink 1
    local PUSHOVER=0
    if [ $# -eq 0 ];then
        txt="Done"
    elif [ $# -gt 1 ] && ( [[ "$1" == "p" ]] || [[ "$1" == "P" ]] );then
        txt="${@:2}"
        PUSHOVER=1
    else
        txt="$*"
    fi
    # log errything to file
    logstr ${txt}
    if dbus-send --session --dest=org.freedesktop.DBus --type=method_call --print-reply /org/freedesktop/DBus org.freedesktop.DBus.ListNames | grep -q org.freedesktop.Notifications;then
        notify-send -t 10000 -a A-Notice ${txt}
    else
        echo "  A(): no org.freedesktop.DBus"
    fi
    # tmux display-message
    # TODO some tmux check if we are @localhost or remote
    #tmux_txt=$(echo ${txt} | tr '\n' ' ' | sed "s| \+| |g")
    #tmux display-message "A(): ${tmux_txt}"
    # if we want pushover
    if [ ${PUSHOVER} -eq 1 ];then
        local _config=~/.pushoverrc
        # check if config exists
        if [ ! -f ${_config} ]; then
            echo "  A(): Config file ${_config} does not exist."
            return 1
        fi
        # source config
        source ${_config}
        # check if vars are present
        #if (( ! ${+pushover_userkey} )) || (( ! ${+pushover_apitoken} )); then
        if [[ -v pushover_userkey && -v pushover_apitoken ]]; then
        else
            echo "  A(): pushover_userkey or pushover_apitoken is not set"
            return 2
        fi
        if [[ "$1" == "P" ]];then
            local notify_timeout=10
            # clear the cmd
            zsh_notifier_cmd=
            echo "  A(): Ctrl+C to cancel, Enter to continue or wait ${notify_timeout}s"
            read -t ${notify_timeout} input_str
        fi
        # make post data and post to pushover
        ts=$(date +%s)
        txt="$(urlencode "${txt}")"
        post_data="token=${pushover_apitoken}&user=${pushover_userkey}&message=${txt}&timestamp=${ts}&html=1"
        #echo "${txt}"
        #echo "${post_data}"
        local response=$(curl -s https://api.pushover.net/1/messages.json -d "${post_data}")
        # TODO parse json response?
        if [ $? -eq 0 ]; then
            return 0
        else
            echo "  A(): Failed to deliver message to pushover.net"
            return 3
        fi
    fi
}

function AA() {
    if [ $# -eq 0 ];then
        txt="Done"
    else
        txt="$*"
    fi
    A p ${txt}
}

# pretty-time function
function pretty_time() {
    if (( $# == 0 )); then
        echo 'Input required'
        return 1
    fi
    local human total_seconds=$1
    local days=$(( total_seconds / 60 / 60 / 24 ))
    local hours=$(( total_seconds / 60 / 60 % 24 ))
    local minutes=$(( total_seconds / 60 % 60 ))
    local seconds=$(( total_seconds % 60 ))
    (( days > 0 )) && human+="${days}d "
    (( hours > 0 )) && human+="${hours}h "
    (( minutes > 0 )) && human+="${minutes}m "
    human+="${seconds}s"
    echo "$human"
    return
}

function pretty_size() {
    if [[ $# == 2 ]] && [[ $1 == "i" ]]; then
        echo $2 | numfmt --to=iec-i
    elif [[ $# == 1 ]]; then
        echo $1 | numfmt --to=iec
    elif [[ $# == 0 ]]; then
        numfmt --to=iec
    fi
}

function calc() {
    str="$*"
    result=$( echo "${str}" | bc -l )
    echo ${str} = ${result}
}

function pushover() {
    A p $*
}

#
#if (( ${+commands[notify-send]} )); then
    notify-preexec-hook() {
        zsh_notifier_cmd="$1"
        zsh_notifier_time="$(date +%s)"
    }
    notify-precmd-hook() {
        local returncode=$(echo $?)
        local time_taken
        if [[ "${zsh_notifier_cmd}" != "" ]]; then
            time_taken=$(( `date +%s` - ${zsh_notifier_time} ))
            local str="cmd:   ${zsh_notifier_cmd}
code:  ${returncode}
dir:   ${PWD}
start: $(date -d @${zsh_notifier_time} +"%Y-%m-%d %H:%M:%S")
time:  $( pretty_time ${time_taken} )
end:   $( date +"%Y-%m-%d %H:%M:%S" )
tty:   ${TTY}"
            if (( ${time_taken} > ${REPORTTIME_AA} )); then
                str="${USER}@${HOST}
${str}"
                A P ${str}
            elif (( ${time_taken} > ${REPORTTIME_A} )); then
                A ${str}
            fi
        fi
        zsh_notifier_cmd=
    }
#fi

strlen () {
    FOO=$1
    local zero='%([BSUbfksu]|([FB]|){*})'
    LEN=${#${(S%%)FOO//$~zero/}}
    echo $LEN
}

# show right prompt with date ONLY when command is executed
timestamp-preexec () {
    DATE=$( date +"[%H:%M:%S]" )
    local len_right=$( strlen "${DATE}" )
    len_right=$(( ${len_right}+1 ))
    local right_start=$((${COLUMNS} - ${len_right}))
    local len_cmd=$( strlen "$@" )
    local len_prompt=$(strlen "${PROMPT}" )
    local len_left=$((${len_cmd}+${len_prompt}))
    RDATE="\033[${right_start}C ${DATE}"
    if [ ${len_left} -lt ${right_start} ]; then
        # command does not overwrite right prompt
        # ok to move up one line
        echo -e "\033[1A${RDATE}"
    else
        echo -e "${RDATE}"
    fi
}

[[ -z ${preexec_functions} ]] && preexec_functions=()
preexec_functions=( ${preexec_functions} notify-preexec-hook )

[[ -z ${precmd_functions} ]] && precmd_functions=()
precmd_functions=( ${precmd_functions} notify-precmd-hook )

#  vim: set ts=4 sw=4 tw=0 et filetype=zsh :
