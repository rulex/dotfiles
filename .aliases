#!/bin/bash
alias ..='cd ..'
alias ...='cd ../..'
alias -- -='cd -'

alias please='sudo'
alias rm='rm -I'

#alias g='grep -in'

alias ls='ls -F --color=auto --time-style="+%Y-%m-%d %H:%M:%S" '
alias lsa='ls -lah'
alias l='ls -lah'
alias ll='ls -l'
alias la='ls -lA'
alias lc='ls -lthrc'
alias lca='ls -ltrca'
alias sl=ls
#alias dt='date +"%Y-%m-%dT%H:%M:%S"'
function dt() {
	if [[ $# == 0 ]]; then
		# pretty print now
		date +"%Y-%m-%d %H:%M:%S"
	elif [[ $# == 1 ]] && [[ $1 != "p" ]]; then
		# pretty print input unix ts
		date +"%Y-%m-%d %H:%M:%S" --date @"$1"
	elif [[ $# == 2 ]] && [[ $1 == "p" ]]; then
		# pretty print input diff seconds
		local human total_seconds=$2
		local days=$(( total_seconds / 60 / 60 / 24 ))
		local hours=$(( total_seconds / 60 / 60 % 24 ))
		local minutes=$(( total_seconds / 60 % 60 ))
		local seconds=$(( total_seconds % 60 ))
		(( days > 0 )) && human+="${days}d "
		(( hours > 0 )) && human+="${hours}h "
		(( minutes > 0 )) && human+="${minutes}m "
		human+="${seconds}s"
		echo "$human"
	fi
}

function ds() {
    if [[ $# == 0 ]]; then
        du --time --time-style="+%Y-%m-%d %H:%M:%S" -shc * | sort -k 1 -h
    else
        du --time --time-style="+%Y-%m-%d %H:%M:%S" -shc $* | sort -k 1 -h
    fi
}

alias new_uuid='cat /dev/urandom | tr -dc "a-zA-Z0-9" | fold -w 32 | head -n 1'
random-string() {
    cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w ${1:-32} | head -n 1
}

alias grep='grep --color=auto'
alias egrep='egrep --color=auto'

alias afind='ack-grep -il'

alias xterm='xterm -bg black -fg white'

alias p='pacman'
alias P='packer'
alias s='sudo '
alias w='w -f'
alias fig='docker-compose'
alias px='ps auxf'
alias pxg='ps auxf|grep -i'
#alias t='TERM=screen-256color-bce tmux'
alias t='tmux'
#alias ds='du --time --time-style="+%Y-%m-%d %H:%M:%S" -shc * | sort -k 1 -h'
alias netlisteners='lsof -i -P | grep LISTEN'
alias g='git'
alias gs='git status'
alias ga='git add'
alias gb='git branch'
alias gba='git branch -av'
alias gc='git commit'
alias gd='git diff'
alias gco='git checkout'
alias gm='git merge'
alias gl="git log --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen[%ci (%cr)] %C(bold blue)<%an>%Creset' --abbrev-commit"
alias glg="git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen[%ci (%cr)] %C(bold blue)<%an>%Creset' --abbrev-commit"
alias glga="git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen[%ci (%cr)] %C(bold blue)<%an>%Creset' --abbrev-commit --all"
alias gln='git log --pretty=format:"%C(red)%h%C(reset) - %s %C(green)[%ci (%cr)] %C(bold blue)<%an>%C(reset)" --name-only'
alias gls='git show --pretty=format:"%C(red)%h%C(reset) - %s %C(green)[%ci (%cr)] %C(bold blue)<%an>%C(reset)"'
alias glc='git shortlog --no-merges -nes'
alias grup='git remote update'
alias gwc='git whatchanged -p --abbrev-commit --pretty=medium'

#alias A='notify-send -t 10000 -a A'
alias mysql='mysql --auto-rehash'
alias cv='progress'

logstr() {
    # replace newline with newline+tab for extra fancy indented text
    logstr=$( echo "${1//
/
    }" )
    echo "$(dt) ${logstr}" >> ~/.a.log
}

A() {
	if [ $# -eq 0 ];then
		txt="Done"
	else
		txt="$*"
	fi
	# log errything to file
    logstr ${txt}
	notify-send -t 10000 -a A-Notice ${txt}
}

AA() {
	if [ $# -eq 0 ];then
		txt="Done"
	else
		txt="$*"
	fi
	# log errything to file
    logstr ${txt}
	notify-send -t 10000 -a A-Notice ${txt}
	if type pushover 2 > /dev/null; then
		pushover "${txt}"
	fi
}

# pretty-time function
function pretty_time() {
	if (( $# == 0 )); then
		echo 'Input required'
        exit
	fi
	local human total_seconds=$1
	local days=$(( total_seconds / 60 / 60 / 24 ))
	local hours=$(( total_seconds / 60 / 60 % 24 ))
	local minutes=$(( total_seconds / 60 % 60 ))
	local seconds=$(( total_seconds % 60 ))
	(( days > 0 )) && human+="${days}d "
	(( hours > 0 )) && human+="${hours}h "
	(( minutes > 0 )) && human+="${minutes}m "
	human+="${seconds}s"
	echo "$human"
}

function pretty_size() {
	if [[ $# == 2 ]] && [[ $1 == "i" ]]; then
		echo $2 | numfmt --to=iec-i
	else
		echo $1 | numfmt --to=iec
	fi
}

function calc() {
	str="$*"
	result=$( echo "${str}" | bc -l )
	echo ${str} = ${result}
}

function pushover() {
	_config=~/.pushoverrc
	# check if config exists
	if [ ! -f ${_config} ]; then
		echo "File ${_config} does not exist."
		return 1
	fi
	# source config
	source ${_config}
	# check if vars are present
	if [ -z ${pushover_userkey} ] || [ -z ${pushover_apitoken} ]; then
		echo "pushover_userkey or pushover_apitoken is not set"
		return 2
	fi
	msg="empty msg"
	if [ $# -gt 0 ]; then
		msg=$*
	fi
	ts=$(date +%s)
    post_data="token=${pushover_apitoken}&user=${pushover_userkey}&message=${msg}&timestamp=${ts}&html=1"
    #echo ${post_data}
	curl https://api.pushover.net/1/messages.json -d "${post_data}"
    # TODO parse json response
	if [ $? -eq 0 ]; then
        return 0
    else
        return 3
    fi
}

#
if [[ -x $( which notify-send ) ]]; then
	notify-preexec-hook() {
		zsh_notifier_cmd="$1"
		zsh_notifier_time="$(date +%s)"
	}
	notify-precmd-hook() {
		local returncode=$(echo $?)
		local time_taken
		if [[ "${zsh_notifier_cmd}" != "" ]]; then
			time_taken=$(( `date +%s` - ${zsh_notifier_time} ))
			local str="cmd:   ${zsh_notifier_cmd}
code:  ${returncode}
dir:   ${PWD}
start: $(date -d @${zsh_notifier_time} +"%Y-%m-%d %H:%M:%S")
time:  $( pretty_time ${time_taken} )
end:   $( date +"%Y-%m-%d %H:%M:%S" )
tty:   ${TTY}"
			if (( ${time_taken} > ${REPORTTIME_AA} )); then
				str="${USER}@${HOST}
${str}"
				local notify_timeout=10
				# XXX read with timeout
				echo "Ctrl+C to cancel, Enter to continue or wait ${notify_timeout}"
				read -t ${notify_timeout} input_str
				AA ${str}
			elif (( ${time_taken} > ${REPORTTIME_A} )); then
				A ${str}
			fi
		fi
		zsh_notifier_cmd=
	}
fi

strlen () {
    FOO=$1
    local zero='%([BSUbfksu]|([FB]|){*})'
    LEN=${#${(S%%)FOO//$~zero/}}
    echo $LEN
}

# show right prompt with date ONLY when command is executed
date-preexec () {
    DATE=$( date +"[%H:%M:%S]" )
    local len_right=$( strlen "$DATE" )
    len_right=$(( $len_right+1 ))
    local right_start=$(($COLUMNS - $len_right))
    local len_cmd=$( strlen "$@" )
    local len_prompt=$(strlen "$PROMPT" )
    local len_left=$(($len_cmd+$len_prompt))
    RDATE="\033[${right_start}C ${DATE}"
    if [ $len_left -lt $right_start ]; then
        # command does not overwrite right prompt
        # ok to move up one line
        echo -e "\033[1A${RDATE}"
    else
        echo -e "${RDATE}"
    fi
}

[[ -z ${preexec_functions} ]] && preexec_functions=()
preexec_functions=( ${preexec_functions} notify-preexec-hook date-preexec )

[[ -z ${precmd_functions} ]] && precmd_functions=()
precmd_functions=( ${precmd_functions} notify-precmd-hook )

