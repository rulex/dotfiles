#!/bin/bash
alias ..='cd ..'
alias ...='cd ../..'
alias -- -='cd -'

alias please='sudo'
alias rm='rm -I'

#alias g='grep -in'

alias ls='ls -F --color=auto --time-style="+%Y-%m-%d %H:%M:%S" '
alias lsa='ls -lah'
alias l='ls -lah'
alias ll='ls -l'
alias la='ls -lA'
alias lc='ls -lthrc'
alias lca='ls -ltrca'
alias sl=ls
#alias dt='date +"%Y-%m-%dT%H:%M:%S"'
function dt() {
	if [[ $# == 0 ]]; then
		# pretty print now
		date +"%Y-%m-%d %H:%M:%S"
	elif [[ $# == 1 ]]; then
        if [[ $1 == "w" ]]; then
            date +"%Y-%m-%d %H:%M:%S W%V"
        else
            # pretty print input unix ts
            date +"%Y-%m-%d %H:%M:%S" --date @"$1"
        fi
	elif [[ $# == 2 ]] && [[ $1 == "p" ]]; then
		# pretty print input diff seconds
		local human total_seconds=$2
		local days=$(( total_seconds / 60 / 60 / 24 ))
		local hours=$(( total_seconds / 60 / 60 % 24 ))
		local minutes=$(( total_seconds / 60 % 60 ))
		local seconds=$(( total_seconds % 60 ))
		(( days > 0 )) && human+="${days}d "
		(( hours > 0 )) && human+="${hours}h "
		(( minutes > 0 )) && human+="${minutes}m "
		human+="${seconds}s"
		echo "$human"
	fi
}

function ds() {
    if [[ $# == 0 ]]; then
        du --time --time-style="+%Y-%m-%d %H:%M:%S" -shc * | sort -k 1 -h
    else
        du --time --time-style="+%Y-%m-%d %H:%M:%S" -shc $* | sort -k 1 -h
    fi
}

alias new_uuid='cat /dev/urandom | tr -dc "a-zA-Z0-9" | fold -w 32 | head -n 1'
random-string() {
    cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w ${1:-32} | head -n 1
}

function px() {
    if [[ $# == 0 ]]; then
        ps auxf
    elif [[ $# -ge 1 ]]; then
        ps auxf | grep -i $*
    fi
}

function pwatch() {
    local re='^[0-9]+$'
    echo "${1}"
    if ! [[ ${1} =~ $re ]] ; then
        watch -g pgrep ${1}; A
    else
        watch -g ps -opid -p ${1}; A
    fi
}

function agrep() {
    # align grep
    grep -Hni "${1}" ${@} | sed -e "s#:#¤#" -e "s#:#¤#" | column -t -s "¤" -o " | " -N file,line,content | grep -i "${1}"
}

alias grep='grep --color=auto'
alias egrep='egrep --color=auto'
alias -g align='sed -e "s#¤#|#" -e "s#:#¤#" | column -t -s "¤" -o " | "'

alias afind='ack-grep -il'

alias xterm='xterm -bg black -fg white'

alias p='pacman'
alias P='packer'
alias s='sudo '
alias w='w -f'
alias fig='docker-compose'
#alias px='ps auxf'
alias pxg='px'
#alias t='TERM=screen-256color-bce tmux'
alias t='tmux'
alias tmuxeey='new -d -s "default" \
    new-window   \; \
    new-window   \; \
    new-window   \; \
    new-window   "htop" \; \
    split-window -h "nmon" \; \
    split-window -v "watch sensors" \; \
    select-pane -L \; \
    split-window -v "journalctl -alf" \; \
    attach \;'
alias tmuxmon='tmux \
    new-window   "htop" \; \
    split-window -h "NMON=ld nmon" \; \
    split-window -v "watch sensors" \; \
    select-pane -L \; \
    split-window -v "journalctl -alf" \;'

#alias ds='du --time --time-style="+%Y-%m-%d %H:%M:%S" -shc * | sort -k 1 -h'
alias netlisteners='lsof -i -P | grep LISTEN'
alias g='git'
alias gs='git status'
alias ga='git add'
alias gb='git branch'
alias gba='git branch -av'
alias gc='git commit'
alias gcv='git commit --verbose'
alias gd='git diff'
alias gco='git checkout'
alias gm='git merge'
alias gl="git log --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen[%ci (%cr)] %C(bold blue)<%an>%Creset' --abbrev-commit"
alias glg="git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen[%ci (%cr)] %C(bold blue)<%an>%Creset' --abbrev-commit"
alias glga="git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen[%ci (%cr)] %C(bold blue)<%an>%Creset' --abbrev-commit --all"
alias gln='git log --pretty=format:"%C(red)%h%C(reset) - %s %C(green)[%ci (%cr)] %C(bold blue)<%an>%C(reset)" --name-only'
alias gls='git show --pretty=format:"%C(red)%h%C(reset) - %s %C(green)[%ci (%cr)] %C(bold blue)<%an>%C(reset)"'
alias glc='git shortlog --no-merges -nes'
alias grup='git remote update'
alias gwc='git whatchanged -p --abbrev-commit --pretty=medium'

alias mysql='mysql --auto-rehash'
alias cv='progress'

function logstr() {
    # replace newline with newline+tab for extra fancy indented text
    logstr=$( echo "${1//
/
    }" )
    echo "$(dt) ${logstr}" >> ~/.a.log
}

function A() {
    local PUSHOVER=0
    if [ $# -eq 0 ];then
        txt="Done"
    elif [ $# -gt 1 ] && ( [[ "$1" == "p" ]] || [[ "$1" == "P" ]] );then
        txt="${@:2}"
        PUSHOVER=1
    else
        txt="$*"
    fi
    # log errything to file
    logstr ${txt}
    notify-send -t 10000 -a A-Notice ${txt}
    # tmux display-message
    # TODO some tmux check if we are @localhost or remote
    #tmux_txt=$(echo ${txt} | tr '\n' ' ' | sed "s| \+| |g")
    #tmux display-message "A(): ${tmux_txt}"
    # if we want pushover
    if [ ${PUSHOVER} -eq 1 ];then
        local _config=~/.pushoverrc
        # check if config exists
        if [ ! -f ${_config} ]; then
            echo "  A(): Config file ${_config} does not exist."
            return 1
        fi
        # source config
        source ${_config}
        # check if vars are present
        if [ -z ${pushover_userkey} ] || [ -z ${pushover_apitoken} ]; then
            echo "  A(): pushover_userkey or pushover_apitoken is not set"
            return 2
        fi
        if [[ "$1" == "P" ]];then
            local notify_timeout=10
            # clear the cmd
            zsh_notifier_cmd=
            echo "  A(): Ctrl+C to cancel, Enter to continue or wait ${notify_timeout}s"
            read -t ${notify_timeout} input_str
        fi
        # make post data and post to pushover
        ts=$(date +%s)
        post_data="token=${pushover_apitoken}&user=${pushover_userkey}&message=${txt}&timestamp=${ts}&html=1"
        #echo ${post_data}
        response=$(curl -s https://api.pushover.net/1/messages.json -d "${post_data}")
        # TODO parse json response?
        if [ $? -eq 0 ]; then
            return 0
        else
            echo "  A(): Failed to deliver message to pushover.net"
            return 3
        fi
    fi
}

function AA() {
	if [ $# -eq 0 ];then
		txt="Done"
	else
		txt="$*"
	fi
    A p ${txt}
}

# pretty-time function
function pretty_time() {
	if (( $# == 0 )); then
		echo 'Input required'
        return 1
	fi
	local human total_seconds=$1
	local days=$(( total_seconds / 60 / 60 / 24 ))
	local hours=$(( total_seconds / 60 / 60 % 24 ))
	local minutes=$(( total_seconds / 60 % 60 ))
	local seconds=$(( total_seconds % 60 ))
	(( days > 0 )) && human+="${days}d "
	(( hours > 0 )) && human+="${hours}h "
	(( minutes > 0 )) && human+="${minutes}m "
	human+="${seconds}s"
	echo "$human"
    return
}

function pretty_size() {
	if [[ $# == 2 ]] && [[ $1 == "i" ]]; then
		echo $2 | numfmt --to=iec-i
	else
		echo $1 | numfmt --to=iec
	fi
}

function calc() {
	str="$*"
	result=$( echo "${str}" | bc -l )
	echo ${str} = ${result}
}

function pushover() {
    A p $*
}

#
if [[ -x $( which notify-send ) ]]; then
	notify-preexec-hook() {
		zsh_notifier_cmd="$1"
		zsh_notifier_time="$(date +%s)"
	}
	notify-precmd-hook() {
		local returncode=$(echo $?)
		local time_taken
		if [[ "${zsh_notifier_cmd}" != "" ]]; then
			time_taken=$(( `date +%s` - ${zsh_notifier_time} ))
			local str="cmd:   ${zsh_notifier_cmd}
code:  ${returncode}
dir:   ${PWD}
start: $(date -d @${zsh_notifier_time} +"%Y-%m-%d %H:%M:%S")
time:  $( pretty_time ${time_taken} )
end:   $( date +"%Y-%m-%d %H:%M:%S" )
tty:   ${TTY}"
			if (( ${time_taken} > ${REPORTTIME_AA} )); then
				str="${USER}@${HOST}
${str}"
				A P ${str}
			elif (( ${time_taken} > ${REPORTTIME_A} )); then
				A ${str}
			fi
		fi
		zsh_notifier_cmd=
	}
fi

strlen () {
    FOO=$1
    local zero='%([BSUbfksu]|([FB]|){*})'
    LEN=${#${(S%%)FOO//$~zero/}}
    echo $LEN
}

# show right prompt with date ONLY when command is executed
timestamp-preexec () {
    DATE=$( date +"[%H:%M:%S]" )
    local len_right=$( strlen "${DATE}" )
    len_right=$(( ${len_right}+1 ))
    local right_start=$((${COLUMNS} - ${len_right}))
    local len_cmd=$( strlen "$@" )
    local len_prompt=$(strlen "${PROMPT}" )
    local len_left=$((${len_cmd}+${len_prompt}))
    RDATE="\033[${right_start}C ${DATE}"
    if [ ${len_left} -lt ${right_start} ]; then
        # command does not overwrite right prompt
        # ok to move up one line
        echo -e "\033[1A${RDATE}"
    else
        echo -e "${RDATE}"
    fi
}

[[ -z ${preexec_functions} ]] && preexec_functions=()
preexec_functions=( ${preexec_functions} notify-preexec-hook timestamp-preexec )

[[ -z ${precmd_functions} ]] && precmd_functions=()
precmd_functions=( ${precmd_functions} notify-precmd-hook )

